---
title: "ä»é›¶æ„å»ºç®€æ˜“Reactåº“"
created: "2022-05-22"
tags: ["React"]

coverImage: "./cover.jpg"
unsplashUrl: ""

bdCloud: ""
biliVideo: ""
---

æœ¬æ–‡å°†ä»é›¶å¼€å§‹ï¼Œé€æ­¥æ„å»ºä¸€ä¸ªç›¸å¯¹ç®€æ˜“ç‰ˆæœ¬çš„ React åº“ã€‚ç”±äºæ˜¯ç®€åŒ–ç‰ˆæœ¬ï¼Œæœ¬æ–‡ä¸­å°†ä¸æ¶‰åŠ React ä¸­æ€§èƒ½ä¼˜åŒ–çš„éƒ¨åˆ†ã€‚

æœ¬æ–‡å°†æ„å»ºçš„ React ç‰ˆæœ¬ä¸º 16.8 ç‰ˆæœ¬ï¼Œå³æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ hooks ç‰¹æ€§ã€‚

æ„å»ºä¹‹å‰ï¼Œç®€å•ä»‹ç»ä¸€ä¸‹æ¯ä¸ªæ­¥éª¤çš„å¤§è‡´å†…å®¹ï¼Œæ–¹ä¾¿å¸¦ç€å°è±¡é˜…è¯»ã€‚

1. createElement å‡½æ•°ï¼Œç”¨è¯¥å‡½æ•°æ¥è½¬åŒ– JSX
2. render å‡½æ•°ï¼Œç±»ä¼¼ ReactDOM ä¸­çš„ render å‡½æ•°
3. å¹¶å‘æ¨¡å¼ï¼Œä½¿ç”¨å¼‚æ­¥é˜²æ­¢ä»£ç åŒæ­¥è¿è¡Œï¼Œé˜»å¡æµè§ˆå™¨ä¸»çº¿ç¨‹
4. Fibersï¼Œåˆ†å‰²ä»»åŠ¡å•å…ƒ
5. render å’Œ commit é˜¶æ®µ
6. reconciliation åè°ƒé˜¶æ®µ
7. å‡½æ•°å¼ç»„ä»¶
8. å®ç° useState å‡½æ•°

## ç¬¬ 0 èŠ‚ å›é¡¾

åœ¨å®ç°æ¯ä¸€æ­¥ä¹‹å‰ï¼Œå…ˆæ¥ç®€å•çš„å›é¡¾ä»¥ä¸‹ä¸€äº›åŸºæœ¬æ¦‚å¿µã€‚å¦‚æœä½ éå¸¸ç†Ÿæ‚‰ Reactï¼ŒJSX å’Œ DOM æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œå¯ä»¥è·³è¿‡è¯¥èŠ‚ã€‚

åœ¨ React ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¸‰è¡Œä»£ç æ¥ç”Ÿæˆä¸€ä¸ªç®€å•çš„ Demoã€‚

```jsx
const element = <h1 title="foo">Hello</h1>
const container = document.getElementById("root")
ReactDOM.render(element, container)
```

ç¬¬ä¸€è¡Œå®šä¹‰äº†ä¸€ä¸ª React å…ƒç´ ï¼Œç¬¬äºŒè¡Œä» DOM ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç¬¬ä¸‰è¡Œå°† React å…ƒç´ æŒ‚è½½åˆ°æ ¹èŠ‚ç‚¹ä¸Šã€‚

**è®©æˆ‘ä»¬ç”¨çº¯ JavaScript ä»£ç æ¥é‡å†™è¿™å‡ è¡Œã€‚**

ç¬¬ä¸€è¡Œä½¿ç”¨ JSX å®šä¹‰ React å…ƒç´ ï¼Œä¸èƒ½ç®—æ˜¯åˆæ³•çš„ JS ä»£ç ï¼Œæˆ‘ä»¬å‡†å¤‡ç”¨çº¯ JS æ¥é‡å†™è¯¥è¡Œã€‚

JSX é€šè¿‡ Babel è½¬åŒ–ä¸º JSï¼Œè½¬åŒ–è¿‡ç¨‹è¯´ä¸ä¸Šå¤æ‚ï¼Œæ‰¾å‡ºåŒ¹é…çš„æ ‡ç­¾åç§°ï¼Œè°ƒç”¨ createElement æ–¹æ³•ï¼Œä¼ å…¥æ ‡ç­¾åç§°ï¼ˆh1ï¼‰ã€å…¶ä»–çš„å±æ€§ propsï¼ˆtitleï¼‰å’Œ childrenï¼ˆHello å­—ç¬¦ä¸²ï¼‰ã€‚

React.createElement å‡½æ•°æ ¹æ®ä¼ å…¥çš„å‚æ•°åˆ›å»ºä¸€ä¸ª objectï¼Œé™¤äº†ç¹ççš„ç±»å‹éªŒè¯ä¹‹å¤–ï¼Œè¿™å°±æ˜¯å®ƒæ‰€ä½œçš„å…¨éƒ¨äº†ã€‚

```jsx
const element = React.createElement("h1", { title: "foo" }, "Hello")
```

è¿™å°±æ˜¯ä¸€ä¸ªå…ƒç´ åœ¨ React ä¸­çš„å®šä¹‰ï¼Œä¸€ä¸ªå«æœ‰ä¸¤ä¸ªå±æ€§çš„ objectï¼štype å’Œ propsã€‚ï¼ˆReact åº“ä¸­è¿˜åœ¨æ­¤å¤„å®šä¹‰äº†å…¶ä»–å±æ€§ï¼Œä½†ç›®å‰æˆ‘ä»¬å…ˆåªå…³å¿ƒè¿™ä¸¤ä¸ªï¼‰

```jsx
const element = {
  type: "h1",
  props: {
    title: "foo",
    children: "Hello",
  },
}
```

`type`æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä»£è¡¨äº†æˆ‘ä»¬éœ€è¦åˆ›å»ºçš„ DOM å…ƒç´ çš„ç±»å‹ï¼Œå¦‚ h1(ä¸€çº§æ ‡é¢˜)æˆ–æ˜¯ p(æ®µè½)ã€‚

ä½†ä¹Ÿæœ‰äº›æƒ…å†µï¼Œè¯¥ type çš„å€¼ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ç§æƒ…å†µæˆ‘ä»¬æ”¾åˆ°ç¬¬ 7 èŠ‚å‡½æ•°å¼ç»„ä»¶å†è®²ã€‚

`props`æ˜¯å¦ä¸€ä¸ª objectï¼Œå…¶ä¸­åŒ…å«æœ‰ä» JSX ä¸­è§£æè¿‡æ¥çš„é”®å€¼å¯¹ï¼ˆæ¯”å¦‚ä¸Šè¿°çš„ title:â€fooâ€ï¼‰å’Œä¸€ä¸ªç‰¹æ®Šçš„å±æ€§ childrenã€‚

ä¸Šè¿°æƒ…å†µä¸­ï¼Œchildren çš„å€¼ä¸ºå­—ç¬¦ä¸²ï¼Œä½†é€šå¸¸æƒ…å†µä¸‹ä¸ºæœ‰å¤šä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œè¿™ä¹Ÿæ˜¯ React å…ƒç´ ä¹Ÿè¢«çœ‹ä½œä¸ºæ ‘çš„åŸå› ã€‚

å…¶ä»–éœ€è¦æ›¿æ¢çš„ä»£ç ä¸º ReactDOM.render æ–¹æ³•ã€‚React åœ¨ render æ–¹æ³•ä¸­å¯¹ DOM åšå‡ºæ”¹åŠ¨ã€‚

```jsx
const node = document.createElement(element.type)
node["title"] = element.props.title
```

é¦–å…ˆï¼Œæˆ‘ä»¬æ ¹æ® type å€¼åˆ›å»ºä¸€ä¸ª node èŠ‚ç‚¹ï¼Œæ¯”å¦‚è¯´ä¸€ä¸ª h1 èŠ‚ç‚¹ã€‚ä¹‹åï¼Œå°†å…¶ä¸Šçš„æ‰€æœ‰å±æ€§æ·»åŠ åˆ° node ä¸Šï¼Œæ¯”å¦‚è¯´ titleã€‚

<aside>
âš™ ä¸ºäº†ä¸æ··æ·†ï¼Œåæ–‡ä¸­å‡ºç°çš„æ‰€æœ‰â€œå…ƒç´ â€ä¸€è¯å‡æŒ‡ä»£Reactå…ƒç´ ï¼Œè€Œç”¨è‹±æ–‡nodeæŒ‡ä»£DOMå…ƒç´ ã€‚

</aside>

ä¹‹åä¸º children åˆ›å»º nodeï¼Œç”±äº children çš„å€¼ä¸ºå­—ç¬¦ä¸²ï¼Œæ‰€ä»¥æˆ‘ä»¬åˆ›å»ºçš„æ˜¯æ–‡æœ¬ nodeã€‚æ–‡æœ¬ node é€šè¿‡[nodeValue](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue)æŒ‡ä»£å†…éƒ¨æ–‡æœ¬å€¼ã€‚

```jsx
const text = document.createTextNode("")
text["nodeValue"] = element.props.children
```

é€šè¿‡ä½¿ç”¨ createTextNodeï¼Œè€Œéåœ¨ä½¿ç”¨ createElement åˆ›å»ºçš„çˆ¶å…ƒç´ ä¸Šé€šè¿‡ innerText æ¥è®¾ç½®æ–‡æœ¬çš„å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ç»Ÿä¸€æ‰€æœ‰ç»„ä»¶çš„é€»è¾‘ã€‚åœ¨æ–‡æœ¬ node èŠ‚ç‚¹ä¸Šï¼Œæˆ‘ä»¬è®¾ç½®å…¶ nodeValue çš„å€¼ä¸º element.props.childrenï¼Œå’Œä¸Šé¢ä¸º h1 èŠ‚ç‚¹çš„ title å±æ€§èµ‹å€¼ä¸º element.props.title çš„å†™æ³•äº«æœ‰ç›¸åŒçš„ä»£ç é€»è¾‘ã€‚

æœ€åï¼Œæˆ‘ä»¬å°† textNode æ”¾åˆ° h1 èŠ‚ç‚¹ä¸‹ï¼Œå†å°† h1 æ”¾åˆ°æ ¹èŠ‚ç‚¹(container)ä¸‹ã€‚

```jsx
node.appendChild(text)
container.appendChild(node)
```

è‡³æ­¤ï¼Œæˆ‘ä»¬å®ç°äº†åªç”¨ JSï¼Œé€šè¿‡åˆ›å»ºèŠ‚ç‚¹æ¥åˆ›å»ºé¡µé¢çš„ Demoã€‚

```jsx
const element = {
  type: "h1",
  props: {
    title: "foo",
    children: "Hello",
  },
}

const container = document.getElementById("root")

const node = document.createElement(element.type)
node["title"] = element.props.title

const text = document.createTextNode("")
text["nodeValue"] = element.props.children

node.appendChild(text)
container.appendChild(node)
```

## ç¬¬ 1 èŠ‚ createElement å‡½æ•°

ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å›é¡¾äº†ä¸€äº›åŸºæœ¬æ¦‚å¿µï¼Œä¹Ÿç”¨çº¯ JS å®ç°äº†ä¸€ä¸ªç±»ä¼¼ React æ¸²æŸ“æµç¨‹çš„ Demoï¼Œä½†è¿™äº›ä»£ç éƒ½æ˜¯ç¡¬ç¼–ç ï¼Œæˆ‘ä»¬éœ€è¦éå†ä¸€ä¸ªå…ƒç´ çš„æ‰€æœ‰å±æ€§ï¼ŒåŠ¨æ€åœ°å»æ‹·è´ã€‚

è®©æˆ‘ä»¬ä»æ–°å¼€å§‹ï¼Œè¿™æ¬¡å°†ä¼šæ˜¯ä¸€ä¸ªå®Œæ•´çš„ React åº“ã€‚

é¦–å…ˆæ˜¯ createElement å‡½æ•°ï¼Œä»–å°†ç”¨äºå°† JSX ä»£ç â€¦

```jsx
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
```

â€¦è½¬æ¢ä¸º JS ä»£ç ã€‚

```jsx
const element = React.createElement(
  "div",
  { id: "foo" },
  React.createElement("a", null, "bar"),
  React.createElement("b")
)
```

åŒ document.createElement çš„å‡½æ•°ç­¾åç±»ä¼¼ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸º typeï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º propsï¼Œç”¨å‰©ä½™å‚æ•°è·å–ä¹‹åçš„æ‰€æœ‰å‚æ•°ä½œä¸º childrenï¼Œå°† props å’Œ children æ”¾å…¥ props ä¸­ã€‚

```jsx
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children,
    },
  }
}
```

æ¯”å¦‚ï¼Œæ‰§è¡Œ`createElement("div")` ä¼šè¿”å›

```json
{
  "type": "div",
  "props": { "children": [] }
}
```

`createElement("div", null, a)` ä¼šè¿”å›

```json
{
  "type": "div",
  "props": { "children": [a] }
}
```

`createElement("div", null, a, b)` ä¼šè¿”å›

```json
{
  "type": "div",
  "props": { "children": [a, b] }
}
```

æ­¤æ—¶ children æ•°ç»„ä¸­çš„å…ƒç´ å¯èƒ½ä¸ºåŸºç¡€ç±»å‹å¦‚å­—ç¬¦ä¸²æˆ–æ•°å­—ã€‚æˆ‘ä»¬å°†æ‰€æœ‰ä¸æ˜¯ object ç±»å‹çš„å…ƒç´ ä¼ å…¥ createTextElement å‡½æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ª objectï¼Œå…¶ type çš„å€¼ä¸º`TEXT_ELEMENT`ã€‚

```jsx
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object" ? child : createTextElement(child)
      ),
    },
  }
}
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
```

è¿™ä¹ˆåšçš„ç›®çš„æ˜¯ç»Ÿä¸€æ•°æ®ç±»å‹ã€‚å¦‚ h1ã€p å’Œ strong ç­‰æ ‡ç­¾éƒ½ä¼šé€šè¿‡ createElement è¢«è½¬åŒ–ä¸ºä¸€ä¸ªæœ‰ type å’Œ props å±æ€§çš„ objectï¼Œä¸” props ä¸­å­˜å‚¨æœ‰ style æˆ– title ç­‰å±æ€§ï¼Œchildren ä¸ºä¸€ä¸ªæ•°ç»„ï¼›å­—ç¬¦ä¸²æˆ–æ˜¯æ•°å­—åˆ™ä¼šè¢« createTextElement è½¬åŒ–ä¸ºå¦ä¸€ç§ç±»å‹çš„ objectï¼Œtype çš„å€¼ä¸º TEXT_ELEMENTï¼Œprops ä¸­åªæœ‰ä½œä¸ºå­—é¢å€¼çš„ nodeValue å’Œä¸€ä¸ªç©ºæ•°ç»„ childrenã€‚

<aside>
âš™ Reactå¹¶ä¸ä¼šé’ˆå¯¹åŸºæœ¬ç±»å‹çš„èŠ‚ç‚¹åšå¦‚ä¸Šæ“ä½œï¼Œæˆ–æ˜¯ç»™childrenèµ‹å€¼ä¸ºç©ºæ•°ç»„ã€‚å†æ¬¡åªæ˜¯èƒ½ç®€åŒ–ä»£ç ï¼Œæœ¬æ–‡åªæ³¨é‡ç®€ä»‹è€Œéæ€§èƒ½ã€‚

</aside>

ç›®å‰æˆ‘ä»¬ä»åœ¨ä½¿ç”¨ React ä¸­çš„ createElement æ¥è½¬åŒ– JSXï¼Œæˆ‘ä»¬éœ€è¦æ›¿æ¢ä¸ºä¸Šè¿°çš„ createElementã€‚

ä½†åœ¨è¿™ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆä¸ºæˆ‘ä»¬çš„åº“èµ·ä¸€ä¸ªåå­—ï¼Œå°±å«ä»– Didactã€‚

```jsx
const Didact = {
  createElement,
}
```

å°† createElement åŠ å…¥åˆ° Didact ä¸­ã€‚

è®© Babel ä½¿ç”¨ Didact.createElement è€Œé React.createElementï¼Œæˆ‘ä»¬åœ¨åˆå§‹åŒ– element ä¸€è¡Œçš„ä¸Šæ–¹æ·»åŠ å¦‚ä¸‹ä»£ç ï¼š

```jsx
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
```

æœ‰äº†è¿™è¡Œä»£ç ï¼Œbabel å°†ä¼šç”¨æˆ‘ä»¬æŒ‡å®šçš„ Didact.createElement å»è½¬åŒ– JSXã€‚

åˆ°è¿™é‡Œä¸€èˆ¬è¿˜ä¼šé‡åˆ°å¦ä¸€ä¸ªé”™è¯¯ï¼Œå†æ·»åŠ å¦‚ä¸‹ä»£ç åˆ°æ–‡ä»¶æœ€é¡¶éƒ¨ã€‚

```jsx
/* @jsxRuntime classic */
```

## ç¬¬ 2 èŠ‚ render å‡½æ•°

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å®ç° ReactDOM.render å‡½æ•°ã€‚æˆ‘ä»¬æš‚æ—¶åªå…³æ³¨å¦‚ä½•å‘æ ¹èŠ‚ç‚¹ä¸­æ·»åŠ  nodeï¼Œä¹‹åå†å¤„ç†æ›´æ–°å’Œåˆ é™¤çš„é€»è¾‘ã€‚

æˆ‘ä»¬é¦–å…ˆæ ¹æ®å…ƒç´ çš„ type æ¥åˆ›å»º node èŠ‚ç‚¹ï¼Œå†å°†åˆ›å»ºçš„èŠ‚ç‚¹æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹ä¸Šã€‚

```jsx
function render(element, container) {
  const dom = document.createElement(element.type)

  container.appendChild(dom)
}
```

æˆ‘ä»¬ä½¿ç”¨é€’å½’ï¼Œéå†æ¯ä¸ªå­å…ƒç´ ï¼Œå¹¶å¯¹æ¯ä¸ªå­å…ƒç´ åšç›¸åŒçš„äº‹ã€‚å¯¹äºæ ¹å…ƒç´ æ¥è¯´ï¼Œçˆ¶èŠ‚ç‚¹æ˜¯ html ä¸­ body ä¸‹ id ä¸º root çš„ div æ ‡ç­¾ï¼Œå¯¹äºå¶å­å…ƒç´ æ¥è¯´ï¼Œåˆ™ä¸ºåˆšåˆ›å»ºçš„ dom å˜é‡ã€‚

```jsx
function render(element, container) {
  const dom =
    element.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(element.type)

  const isProperty = key => key !== "children"
  Object.keys(element.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = element.props[name]
    })

  element.props.children.forEach(child => render(child, dom))

  container.appendChild(dom)
}
```

æˆ‘ä»¬è¿˜éœ€è¦å¤„ç†èŠ‚ç‚¹æ˜¯å¦ä¸ºçº¯æ–‡æœ¬çš„æƒ…å†µï¼Œå¦‚æœå…ƒç´ çš„ type å€¼ä¸º TEXT_ELEMENTï¼Œåˆ™è°ƒç”¨ createTextNodeã€‚

æœ€åï¼ŒæŠŠå…ƒç´ ä¸Š props ä¸­é™¤äº† children çš„æ‰€æœ‰å±æ€§ï¼ŒåŸå°ä¸åŠ¨çš„æ‹·è´åˆ° dom å˜é‡ä¸Šã€‚

[https://codesandbox.io/s/didact-2-k6rbj](https://codesandbox.io/s/didact-2-k6rbj)

- æœ€ç»ˆä»£ç 

  ```jsx
  function createElement(type, props, ...children) {
    return {
      type,
      props: {
        ...props,
        children: children.map(child =>
          typeof child === "object" ? child : createTextElement(child)
        ),
      },
    }
  }

  function createTextElement(text) {
    return {
      type: "TEXT_ELEMENT",
      props: {
        nodeValue: text,
        children: [],
      },
    }
  }

  function render(element, container) {
    const dom =
      element.type == "TEXT_ELEMENT"
        ? document.createTextNode("")
        : document.createElement(element.type)

    const isProperty = key => key !== "children"
    Object.keys(element.props)
      .filter(isProperty)
      .forEach(name => {
        dom[name] = element.props[name]
      })

    element.props.children.forEach(child => render(child, dom))

    container.appendChild(dom)
  }

  const Didact = {
    createElement,
    render,
  }

  /** @jsx Didact.createElement */
  const element = (
    <div id="foo">
      <a>bar</a>
      <b />
    </div>
  )
  const container = document.getElementById("root")
  Didact.render(element, container)
  ```

å¦‚æœä½ é‡åˆ°äº† pragma and pragmaFrag cannot be set when runtime is automatic é”™è¯¯ï¼Œå°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ°æ–‡ä»¶çš„æœ€é¡¶ç«¯ã€‚

```jsx
/** @jsxRuntime classic */
```

## ç¬¬ 3 èŠ‚ å¹¶å‘æ¨¡å¼

åœ¨å®ç°å…¶ä»–é€»è¾‘ä¹‹å‰ï¼Œåˆ°ç›®å‰ä¸ºæ­¢çš„ä»£ç ä¸­å­˜åœ¨ä¸€ä¸ªå°é—®é¢˜ã€‚

åœ¨é€’å½’æ‰§è¡Œ render å‡½æ•°çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæˆ‘ä»¬çš„ tree è¿‡å¤§ï¼Œåˆ™ä¼šé˜»å¡æµè§ˆå™¨çš„è¿è¡Œã€‚æ¯”å¦‚åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæµè§ˆå™¨éœ€è¦å¤„ç†ç”¨æˆ·è¾“å…¥æˆ–æ˜¯ä¿æŒåŠ¨ç”»å¹³æ»‘æ¸²æŸ“ï¼Œåˆ™åªæœ‰é€’å½’è°ƒç”¨çš„ render å…¨éƒ¨æ‰§è¡Œå®Œæ¯•åï¼Œæµè§ˆå™¨æ‰èƒ½æ¥æ”¶å¤„ç†å…¶ä»–äº‹æƒ…ã€‚

æ¢å¥è¯è¯´å°±æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦å¼‚æ­¥åœ°è°ƒç”¨ render å‡½æ•°ã€‚

æˆ‘ä»¬å°†æ•´ä¸ªä»»åŠ¡åˆ†æˆå¤šä¸ªå°ä»»åŠ¡ï¼Œæ¯ä¸ªå°ä»»åŠ¡æ‰§è¡Œå®Œæ¯•åï¼Œæˆ‘ä»¬å°†äº‹ä»¶å¾ªç¯å›åˆ°æµè§ˆå™¨ä¸»è¿›ç¨‹ã€‚

```jsx
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)

function performUnitOfWork(nextUnitOfWork) {
  // TODO
}
```

æˆ‘ä»¬ç”¨ requestIdleCallback æ¥å®ç°å¾ªç¯ï¼Œä½ å¯ä»¥æŠŠå®ƒæƒ³æˆæ˜¯ setTimeoutï¼Œä½†ä¸åŒçš„æ˜¯æµè§ˆå™¨å°†ä¼šåœ¨ç©ºé—²æ—¶è°ƒç”¨ä¼ å…¥çš„å›è°ƒå‡½æ•°ã€‚

React å·²ç»ä¸å†ä½¿ç”¨ requestIdleCallback æ¥è°ƒåº¦ä»»åŠ¡äº†ï¼Œå®ƒæœ‰ä¸“é—¨çš„ scheduler åŒ…ã€‚

ä¼ å…¥ requestIdleCallback çš„å›è°ƒå‡½æ•°æœ‰ deadline å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…¶æ¥æŸ¥çœ‹ï¼Œè¿˜æœ‰å¤šå°‘æ—¶é—´æµè§ˆå™¨ä¼šæ¥ç®¡çº¿ç¨‹ã€‚

æˆªæ­¢åˆ° 2019 å¹´ 11 æœˆï¼ŒReact çš„å¹¶è¡Œæ¨¡å¼è¿˜ä¸æ˜¯å¾ˆç¨³å®šï¼Œç¨³å®šç‰ˆæœ¬çš„å¾ªç¯ç±»ä¼¼å¦‚ä¸‹ï¼š

```jsx
while (nextUnitOfWork) {
  nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
}
```

å®šä¹‰ performUnitOfWork å‡½æ•°ï¼Œç”¨äºå¤„ç†ä»»åŠ¡å•å…ƒï¼Œå¹¶è¿”å›ä¸‹ä¸€ä¸ªä»»åŠ¡å•å…ƒã€‚

## ç¬¬ 4 èŠ‚ Fibers

ä¸ºæ•´ç†ä»»åŠ¡å•å…ƒï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªæ•°æ®ç»“æ„ï¼šfiber æ ‘ã€‚

ä¸ºæ¯ä¸€ä¸ªå…ƒç´ èŠ‚ç‚¹åˆ›å»ºä¸€ä¸ªå¯¹åº”çš„ fiber èŠ‚ç‚¹ï¼Œæ¯ä¸ª fiber èŠ‚ç‚¹éƒ½å°†æ˜¯ä¸€ä¸ªå°ä»»åŠ¡å•å…ƒã€‚

å‡è®¾æˆ‘ä»¬å‘æ¸²æŸ“ä»¥ä¸‹ fiber æ ‘ï¼š

```jsx
Didact.render(
  <div>
    <h1>
      <p />
      <a />
    </h1>
    <h2 />
  </div>,
  container
)
```

![https://pomb.us/static/a88a3ec01855349c14302f6da28e2b0c/ac667/fiber1.png](https://pomb.us/static/a88a3ec01855349c14302f6da28e2b0c/ac667/fiber1.png)

åœ¨ render ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»º fiber æ ¹èŠ‚ç‚¹ï¼Œå¹¶è®¾ç½®ä¸º nextUnitOfWorkã€‚å‰©ä½™çš„éƒ¨åˆ†å°†ä¼šåœ¨ performUnitOfWork å‡½æ•°ä¸­å‘ç”Ÿï¼Œæ¯ä¸ª fiber èŠ‚ç‚¹å°†ä¼šåšä»¥ä¸‹ä¸‰ä»¶äº‹ã€‚

1. å°†å…ƒç´ æ·»åŠ åˆ° DOM ä¸­
2. ä¸ºå­èŠ‚ç‚¹åˆ›å»º fiber èŠ‚ç‚¹
3. é€‰æ‹©ä¸‹ä¸€ä¸ªå·¥ä½œå•å…ƒ

è¯¥æ•°æ®ç»“æ„çš„ç›®çš„ä¹‹ä¸€æ˜¯ï¼Œæ›´ç®€å•åœ°æ‰¾å‡ºä¸‹ä¸€ä¸ªå·¥ä½œå•å…ƒã€‚è¿™å°±æ˜¯ fiber æœ‰æŒ‡å‘ç¬¬ä¸€ä¸ªå­å…ƒç´ ã€åŒè¾ˆå…ƒç´ å’Œçˆ¶å…ƒç´ é“¾æ¥åœ°åŸå› ã€‚

å®Œæˆä¸€ä¸ª fiber ä¹‹åï¼Œå¦‚æœå®ƒå«æœ‰å­ fiber èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¯¥å­èŠ‚ç‚¹å°±æ˜¯ä¸‹ä¸€ä¸ªå·¥ä½œå•å…ƒã€‚

ä»¥ä¸Šè¿°æƒ…å†µä¸ºä¾‹ï¼Œdiv èŠ‚ç‚¹å®Œä¹‹åå°±æ˜¯ h1 èŠ‚ç‚¹ã€‚

è‹¥æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬ä½¿ç”¨åŒè¾ˆèŠ‚ç‚¹ä½œä¸ºä¸‹ä¸€ä¸ªå·¥ä½œå•å…ƒã€‚

ä»¥ä¸Šè¿°æƒ…å†µä¸ºä¾‹ï¼Œp èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹äº†ï¼Œä¸‹ä¸€ä¸ªå°±æ˜¯ a èŠ‚ç‚¹ã€‚

è‹¥æ—¢æ²¡æœ‰ child ä¹Ÿæ²¡æœ‰ siblingï¼Œåˆ™å»æ‰¾ä»–å”å”ï¼ŒåŒè¾ˆèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

ä»¥ä¸Šè¿°æƒ…å†µä¸ºä¾‹ï¼Œh2 èŠ‚ç‚¹æ—¢æ²¡æœ‰å­èŠ‚ç‚¹ä¹Ÿæ²¡æœ‰åŒè¾ˆèŠ‚ç‚¹ï¼Œåˆ™å›åˆ°åŒè¾ˆ h1 èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ div ä¸­ã€‚

è‹¥çˆ¶èŠ‚ç‚¹æ²¡æœ‰åŒè¾ˆèŠ‚ç‚¹ï¼Œç»§ç»­éå†çˆ¶èŠ‚ç‚¹ï¼Œç›´åˆ°å›åˆ° root èŠ‚ç‚¹ï¼Œæ„å‘³ç€å®Œæˆäº† renderã€‚

å°†ä¸Šè¿°é€»è¾‘å†™æˆä»£ç ä¸ºï¼š

```jsx
function createDom(fiber) {
  //
  const dom =
    fiber.type == "TEXT_ELEMENT" //
      ? document.createTextNode("")
      : document.createElement(fiber.type) //

  const isProperty = key => key !== "children"
  Object.keys(fiber.props) //
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name] //
    })

  return dom //
}

function render(element, container) {
  //
  // TODO set next unit of work //
} //
```

é¦–å…ˆï¼Œé‡å‘½å render ä¸º createDomï¼Œå¦å¤–é‡æ–°å£°æ˜ render å‡½æ•°ã€‚

åœ¨ render å‡½æ•°ä¸­ï¼Œå°† nextUnitOfWork è®¾ç½®ä¸º fiber çš„æ ¹èŠ‚ç‚¹ã€‚

```jsx
function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}

let nextUnitOfWork = null
```

ä¹‹åï¼Œæµè§ˆå™¨ç©ºé—²æ—¶ï¼Œä¼šæ‰§è¡Œ workLoop å‡½æ•°ï¼Œå¼€å§‹ä»æ ¹èŠ‚ç‚¹æ¸²æŸ“ã€‚

```jsx
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)

function performUnitOfWork(fiber) {
  // TODO add dom node
  // TODO create new fibers
  // TODO return next unit of work
}
```

é¦–å…ˆï¼Œåˆ›å»º node èŠ‚ç‚¹ï¼Œå¹¶æ·»åŠ åˆ° DOM ä¸Šã€‚åœ¨ fiber.dom ä¸Šè¿½è¸ª DOM èŠ‚ç‚¹

```jsx
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }

  if (fiber.parent) {
    fiber.parent.dom.appendChild(fiber.dom)
  }

  // TODO create new fibers
  // TODO return next unit of work
}
```

ä¹‹åï¼Œæ¯ä¸ª childï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„ fiber

```jsx
const elements = fiber.props.children
let index = 0
let prevSibling = null

while (index < elements.length) {
  const element = elements[index]

  const newFiber = {
    type: element.type,
    props: element.props,
    parent: fiber,
    dom: null,
  }

  if (index === 0) {
    fiber.child = newFiber
  } else {
    prevSibling.sibling = newFiber
  }

  prevSibling = newFiber
  index++
}

// TODO return next unit of work
```

æ·»åŠ åˆ° fiber æ ‘å½“ä¸­ï¼Œä½œä¸º child æˆ–æ˜¯åŒè¾ˆï¼Œå–å†³äºå…¶æ˜¯å¦æ˜¯ç¬¬ä¸€å­å…ƒç´ ã€‚

æœ€åï¼Œæœå¯»ä¸‹ä¸€ä¸ªå·¥ä½œå•å…ƒã€‚é¦–å…ˆå°è¯• childï¼Œä¹‹ååŒè¾ˆå…ƒç´ ï¼Œæœ€åå”å”å…ƒç´ ã€‚ï¼ˆæ·±åº¦éå†ï¼‰

```jsx
if (fiber.child) {
  return fiber.child
}
let nextFiber = fiber
while (nextFiber) {
  if (nextFiber.sibling) {
    return nextFiber.sibling
  }
  nextFiber = nextFiber.parent
}
```

- å…¨éƒ¨ä»£ç 

  ```jsx
  requestIdleCallback(workLoop)

  function performUnitOfWork(fiber) {
    if (!fiber.dom) {
      fiber.dom = createDom(fiber)
    }

    if (fiber.parent) {
      fiber.parent.dom.appendChild(fiber.dom)
    }

    const elements = fiber.props.children
    let index = 0
    let prevSibling = null

    while (index < elements.length) {
      const element = elements[index]

      const newFiber = {
        type: element.type,
        props: element.props,
        parent: fiber,
        dom: null,
      }

      if (index === 0) {
        fiber.child = newFiber
      } else {
        prevSibling.sibling = newFiber
      }

      prevSibling = newFiber
      index++
    }

    if (fiber.child) {
      return fiber.child
    }
    let nextFiber = fiber
    while (nextFiber) {
      if (nextFiber.sibling) {
        return nextFiber.sibling
      }
      nextFiber = nextFiber.parent
    }
  }

  const Didact = {
    createElement,
    render,
  }

  /** @jsx Didact.createElement */
  const element = (
    <div id="foo">
      <a>bar</a>
      <b />
    </div>
  )
  const container = document.getElementById("root")
  Didact.render(element, container)
  ```

## ç¬¬ 5 èŠ‚ render å’Œ commit é˜¶æ®µ

æˆ‘ä»¬åˆå¦å¤–å¼•å…¥äº†ä¸€ä¸ªæ–°é—®é¢˜ã€‚

æ¯æ¬¡å¤„ç†å…ƒç´ æ—¶ï¼Œæˆ‘ä»¬éƒ½å‘ DOM ä¸­æ·»åŠ äº†ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ã€‚æµè§ˆå™¨å¯èƒ½åœ¨å®Œæˆæ•´ä¸ª fiber æ ‘ä¹‹å‰æ‰“æ–­è¯¥è¿‡ç¨‹ï¼Œæ­¤æ—¶ï¼Œç”¨æˆ·ä¼šæµè§ˆåˆ°ä¸€ä¸ªä¸å®Œæ•´çš„ UIã€‚éœ€è¦é¿å…æ­¤ç§æƒ…å†µã€‚

æˆ‘ä»¬ç§»é™¤å‘ DOM ä¸­æ·»åŠ èŠ‚ç‚¹çš„éƒ¨åˆ†ã€‚

```jsx
function performUnitOfWork(fiber) {
  if(){}

-  if(fiber.parent){
-    fiber.parent.dom.appendChild(fiber.dom)
-  }
}
```

å°†å½“å‰æ­£åœ¨æ¸²æŸ“çš„ root è®°å½•åœ¨å…¨å±€å˜é‡ wipRoot ä¸­ã€‚wip ä»£è¡¨ working in progressï¼Œæ„ä¸ºæ­£åœ¨å¤„ç†çš„ã€‚wipRoot å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ª fiberï¼Œå³ä¸€ä¸ªä»»åŠ¡å•å…ƒï¼Œé‚£ä¹ˆç›´æ¥å†å°† wipRoot èµ‹å€¼ç»™ nextUnitOfWorkï¼Œè®© workLoop å¼€å§‹å¤„ç†è¯¥ä»»åŠ¡å•å…ƒã€‚

```jsx
function render(element, container) {
  wipRoot = {
    // highlight-line
    dom: container,
    props: {
      children: [element],
    },
  }
  nextUnitOfWork = wipRoot // highlight-line
}

let nextUnitOfWork = null
let wipRoot = null // highlight-line
```

ç›´åˆ°æ‰€æœ‰ä»»åŠ¡å•å…ƒå…¨éƒ¨å¤„ç†å®Œæˆï¼ŒnextUnitOfWork ä¸ºç©ºä¸” wipRoot ä¸ä¸ºç©ºï¼Œæˆ‘ä»¬å†å°†æ•´ä¸ª fiber æ ‘æ”¾åˆ° dom ä¸Šã€‚

```jsx
function commitRoot() {
  // highlight-line
  // TODO add nodes to dom // highlight-line
} // highlight-line

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    shouldYield = deadline.timeRemaining() < 1
  }

  if (!nextUnitOfWork && wipRoot) {
    // highlight-line
    commitRoot() // highlight-line
  }

  requestIdleCallback(workLoop)
}
```

å† commitRoot å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬é€’å½’åœ°å°†å­ dom æ”¾åˆ° dom ä¸Šã€‚

```jsx
function commitRoot() {
  commitWork(wipRoot.child)
  wipRoot = null
}

function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
```

## ç¬¬ 6 èŠ‚ reconciliation åè°ƒé˜¶æ®µ

ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªå®ç°äº†æ·»åŠ çš„åŠŸèƒ½ï¼Œç°åœ¨æ¥å®ç°æ›´æ–°å’Œåˆ é™¤ã€‚

æˆ‘ä»¬éœ€è¦å¯¹æ¯”åœ¨ render æ–¹æ³•ä¸­æ¥æ”¶åˆ°åœ° elements å‚æ•°ï¼Œä¸ä¸Šä¸€æ¬¡æ”¾åˆ° DOM ä¸Šçš„ fiber ä½œæ¯”è¾ƒã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¦ä¿å­˜ä¸Šæ¬¡æ”¾åˆ° DOM ä¸Šçš„ fiber çš„å‰¯æœ¬ï¼Œç”¨äºä¸‹æ¬¡æ›´æ–°æ—¶ä½œæ¯”è¾ƒã€‚

å®šä¹‰å…¨å±€å˜é‡ currentRootï¼Œæ„ä¸ºä»¥æŒ‚è½½å¥½äº†çš„ wipRootï¼Œåœ¨éå†å®Œ wipRoot åï¼Œå°† wipRoot çš„å€¼èµ‹ç»™ currentRootï¼ŒwipRoot é‡æ–°èµ‹å€¼ä¸º nulï¼Œæ„ä¸ºæ²¡æœ‰å½“å‰æ­£åœ¨è¿›è¡Œçš„ fiber ä»»åŠ¡ lã€‚

```jsx
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot // highlight-line
  wipRoot = null
}

function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot, // highlight-line
  }
  nextUnitOfWork = wipRoot
}

let nextUnitOfWork = null
let currentRoot = null // highlight-line
let wipRoot = null
```

æ¥ä¸‹æ¥æˆ‘ä»¬æŠŠåœ¨ performUnitOfWork ä¸­ä¸åˆ›å»ºæ–° fiber æœ‰å…³çš„ä»£ç æå–å‡ºæ¥ï¼Œæ”¾åˆ°æ–°çš„å‡½æ•° reconcileChildren ä¸­ã€‚

```jsx
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }

  const elements = fiber.props.children // highlight-line
  reconcileChildren(fiber, elements) // highlight-line

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
  let index = 0
  let prevSibling = null

  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: wipFiber,
      dom: null,
    }

    if (index === 0) {
      wipFiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }
}
```

å†æ­¤ï¼Œæˆ‘ä»¬ç”¨ä¸Šä¸€æ¬¡çš„ fiber ä¸æ–°çš„å­èŠ‚ç‚¹ children åšå¯¹æ¯”ã€‚åœ¨ reconcileChildren å‡½æ•°ä¸­

å¯ä»¥çœ‹å‡ºåœ¨ reconcileChildren å‡½æ•°ä¸­ï¼ŒoldFiber å–è‡ª wipFiber.alternate.childï¼Œå³ä½œæ¯”è¾ƒçš„ä¸¤è€…å‡ä¸ºå­èŠ‚ç‚¹ã€‚ç”±äºå­èŠ‚ç‚¹ä¸ºæ•°ç»„ï¼Œæˆ‘ä»¬åŒæ—¶éå†è¯¥ä¸¤ä¸ªæ•°ç»„ï¼Œä»¥æ–°çš„å­èŠ‚ç‚¹(elements)ä¸ºä¸»è¦ï¼Œé€šè¿‡ä¸‹æ ‡éå† elements çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼ŒåŒæ—¶ç¡®ä¿ oldFiberï¼Œå³æ—§çš„å­èŠ‚ç‚¹ä¸ä¸ºç©ºã€‚

ç”±äºå¯èƒ½å­˜åœ¨æ¡ä»¶æ¸²æŸ“çš„æƒ…å†µï¼Œå³æ–°çš„å­èŠ‚ç‚¹æ•°ç»„å¯èƒ½ä¸ä¹çš„å­èŠ‚ç‚¹æ•°ç»„é•¿åº¦ä¸åŒï¼Œä½†æˆ‘ä»¬åªå¯¹æ¯”ä¸‹æ ‡å¯¹åº”çš„å…ƒç´ ã€‚

```jsx
function reconcileChildren(wipFiber, elements) {
  let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null

  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null

    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type

    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }
    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }

    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      wipFiber.child = newFiber
    } else if (element) {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }
```

ä¸»è¦é€šè¿‡ type æ¥æ¯”è¾ƒ

- æ—§ fiber å’Œæ–° element æœ‰ç›¸åŒçš„ typeï¼Œåˆ™ä¸é‡æ–°åˆ›å»º DOMï¼Œåªæ˜¯æ›´æ–°å±æ€§ã€‚
- å¦‚æœ type ä¸åŒï¼Œè€Œåˆæœ‰æ–°çš„ elementï¼Œåˆ™éœ€è¦é‡æ–°æ ¹æ® type åˆ›å»ºä¸åŒæ ‡ç­¾çš„ DOM
- è‹¥ type ä¸åŒï¼Œä¸” element ä¸å­˜åœ¨ï¼Œæ„ä¸ºåœ¨æ–°çš„ä¸€æ¬¡æ¸²æŸ“ä¸­ï¼Œè¯¥èŠ‚ç‚¹å·²è¢«åˆ é™¤ï¼ŒåŒæ ·æˆ‘ä»¬ä¹Ÿéœ€è¦ä» DOM ä¸­å°†å…¶ç§»é™¤

<aside>
ğŸ‰ Reactåœ¨è¿™é‡Œä½¿ç”¨äº†keyåšæ¯”è¾ƒï¼Œå¯ä»¥åˆ¤æ–­å‡ºé‚£ä¸ªå…ƒç´ ç§»åŠ¨äº†ä½ç½®ï¼Œé€šè¿‡ä¸é‡æ–°æ‰§è¡Œåªç§»åŠ¨äº†ä½ç½®çš„å…ƒç´ ï¼Œä»è€Œå‡å°‘æ€§èƒ½å¼€é”€ã€‚

</aside>

æ—§ fiber ä¸æ–° element æœ‰ç›¸åŒçš„ type çš„æƒ…å†µã€‚type å’Œ dom éƒ½ä¿æŒ oldFiber åŸæ¥çš„å€¼ï¼Œå°† props æ”¹ä¸ºæ–°çš„ element çš„ props çš„å€¼ï¼ŒåŒæ—¶å°†æ„ä¸ºä¸Šä¸€æ¬¡ fiber çš„ alternate èŠ‚ç‚¹èµ‹å€¼ä¸º oldFiberï¼ŒwipFiber ä¸ºè¯¥ fiber çš„çˆ¶èŠ‚ç‚¹ã€‚åœ¨åŠ ä¸Š effectTag å±æ€§ä¸º UPDATEï¼Œæ„ä¸ºéœ€è¦å¯¹è¯¥ fiber è¿›è¡Œæ›´æ–°æ“ä½œã€‚

```jsx
if (sameType) {
  newFiber = {
    type: oldFiber.type,
    props: element.props,
    dom: oldFiber.dom,
    parent: wipFiber,
    alternate: oldFiber,
    effectTag: "UPDATE",
  }
}
```

type ä¸åŒä¸”æœ‰æ–°çš„ elementï¼Œéœ€è¦æ›´æ¢ä¸ºä¸åŒç±»å‹çš„ DOMã€‚

type ä¸ºæ–°çš„ element çš„ typeï¼Œprops ä¹Ÿä¸ºæ–°çš„ element ä¸Šçš„ propsï¼Œç”±äºéœ€è¦æ–°åˆ›å»º DOMï¼Œå°† dom èµ‹å€¼ä¸º nullï¼Œä¹‹ååˆ›å»ºå¥½äº†ä¹‹ååœ¨èµ‹å€¼ï¼Œparent ä¸ºå½“å‰æ­£åœ¨å¤„ç†çš„ fiber(wipFiber)ï¼Œæ–°åˆ›å»ºæ²¡æœ‰ä¸Šä¸€æ¬¡æ¸²æŸ“ï¼Œalternate çš„å€¼ä¸º nullï¼ŒeffectTag ä¸º PLACEMENTï¼Œæ„ä¸ºéœ€è¦æ–°åˆ›å»ºã€‚

```jsx
if (element && !sameType) {
  newFiber = {
    type: element.type,
    props: element.props,
    dom: null,
    parent: wipFiber,
    alternate: null,
    effectTag: "PLACEMENT",
  }
}
```

æœ€åæ˜¯åˆ é™¤èŠ‚ç‚¹æ—¶æ‰€éœ€è¦åˆ›å»ºçš„ fiberï¼Œæˆ‘ä»¬ç›´æ¥å°†æ—§ fiber çš„ effectTag èµ‹å€¼ä¸º DELETIONï¼ŒåŒæ—¶å°†å…¶åŠ å…¥ deletions æ•°ç»„ä¸­ã€‚

```jsx
if (oldFiber && !sameType) {
  oldFiber.effectTag = "DELETION"
  deletions.push(oldFiber) //
}
```

ä½†å½“æˆ‘ä»¬æ‰§è¡Œ fiber æ ‘çš„ç»“æœæŒ‚åœ¨åˆ° DOM ä¸Šæ—¶ï¼Œæˆ‘ä»¬æ˜¯åœ¨ commitRoot å‡½æ•°ä¸­ä» wipRoot å¼€å§‹æ‰§è¡Œçš„ï¼Œæ­¤æ—¶æˆ‘ä»¬æ²¡æœ‰ oldFiberï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œå­˜å‚¨éœ€è¦åˆ é™¤çš„ fiber èŠ‚ç‚¹ï¼Œæ¯æ¬¡è¿è¡Œåˆ° commitRoot å‡½æ•°ä¸­çš„ commitWork å‡½æ•°ä¹‹å‰ï¼Œæˆ‘ä»¬åˆ é™¤æ‰€æœ‰éœ€è¦åˆ é™¤çš„ fiber èŠ‚ç‚¹ã€‚

```jsx
function commitRoot() {
  deletions.forEach(commitWork) //
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}

function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = [] //
  nextUnitOfWork = wipRoot
}

let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null //
```

æ¥ä¸‹æ¥æ˜¯ commitWork å‡½æ•°ï¼Œå¤„ç† fiber çš„æ“ä½œã€‚

å¦‚æœ effectTag çš„å€¼ä¸º PLACEMENTã€‚åˆ™å’Œä»¥å‰ä¸€æ ·ã€‚

```jsx
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
// highlight-start
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  }
// highlight-end
  commitWork(fiber.child)
  commitWork(fiber.sibling)
```

æ·»åŠ æ—¶ DELETION çš„æƒ…å†µï¼Œæˆ‘ä»¬ç›´æ¥åœ¨çˆ¶ dom ä¸Šç§»é™¤å­ domã€‚

```jsx
else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
```

UPDATE çš„æƒ…å†µï¼Œæ‰§è¡Œ createDom å‡½æ•°

```jsx
else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  }

```

å®šä¹‰å‡ ä¸ªå‡½æ•°å¸®åŠ©ç­›é€‰å±æ€§ã€‚

```jsx
const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children" && !isEvent(key)
const isNew = (prev, next) => key => prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)

function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(key => !(key in nextProps) || isNew(prevProps, nextProps)(key))
    .forEach(name => {
      const eventType = name.toLowerCase().substring(2)
      dom.removeEventListener(eventType, prevProps[name])
    })

  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })

  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

  // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name.toLowerCase().substring(2)
      dom.addEventListener(eventType, nextProps[name])
    })
}
```

éœ€è¦ç§»é™¤çš„å±æ€§ç›´æ¥èµ‹å€¼ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œéœ€è¦æ›´æ–°çš„å±æ€§åˆ™èµ‹å€¼ä¸ºæ–°çš„å€¼ã€‚

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“å±æ€§ä¸º onClick ç­‰äº‹ä»¶å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å¦å¤–å¯¹å¾…ã€‚æ›´æ–° isPropertyï¼Œæ’é™¤æ˜¯ event çš„æƒ…å†µã€‚

åœ¨ä¸€å¼€å§‹ï¼Œå¦‚æœäº‹ä»¶å±æ€§æœ‰æ”¹åŠ¨æˆ–æ˜¯è¢«ç§»é™¤ï¼Œæˆ‘ä»¬éƒ½å°†å…¶ç§»é™¤ã€‚ä¹‹åç§»é™¤æ—§å±æ€§ï¼Œåœ¨æ·»åŠ æ–°å±æ€§ã€‚æœ€åæ·»åŠ æ–°çš„äº‹ä»¶å‡½æ•°ã€‚

[https://codesandbox.io/s/didact-6-96533](https://codesandbox.io/s/didact-6-96533)

- æˆªæ­¢åˆ°ç›®å‰ä½ç½®çš„å…¨éƒ¨ä»£ç 

  ```jsx
  function createElement(type, props, ...children) {
    return {
      type,
      props: {
        ...props,
        children: children.map(child =>
          typeof child === "object" ? child : createTextElement(child)
        ),
      },
    }
  }

  function createTextElement(text) {
    return {
      type: "TEXT_ELEMENT",
      props: {
        nodeValue: text,
        children: [],
      },
    }
  }

  function createDom(fiber) {
    const dom =
      fiber.type == "TEXT_ELEMENT"
        ? document.createTextNode("")
        : document.createElement(fiber.type)

    updateDom(dom, {}, fiber.props)

    return dom
  }

  const isEvent = key => key.startsWith("on")
  const isProperty = key => key !== "children" && !isEvent(key)
  const isNew = (prev, next) => key => prev[key] !== next[key]
  const isGone = (prev, next) => key => !(key in next)
  function updateDom(dom, prevProps, nextProps) {
    //Remove old or changed event listeners
    Object.keys(prevProps)
      .filter(isEvent)
      .filter(key => !(key in nextProps) || isNew(prevProps, nextProps)(key))
      .forEach(name => {
        const eventType = name.toLowerCase().substring(2)
        dom.removeEventListener(eventType, prevProps[name])
      })

    // Remove old properties
    Object.keys(prevProps)
      .filter(isProperty)
      .filter(isGone(prevProps, nextProps))
      .forEach(name => {
        dom[name] = ""
      })

    // Set new or changed properties
    Object.keys(nextProps)
      .filter(isProperty)
      .filter(isNew(prevProps, nextProps))
      .forEach(name => {
        dom[name] = nextProps[name]
      })

    // Add event listeners
    Object.keys(nextProps)
      .filter(isEvent)
      .filter(isNew(prevProps, nextProps))
      .forEach(name => {
        const eventType = name.toLowerCase().substring(2)
        dom.addEventListener(eventType, nextProps[name])
      })
  }

  function commitRoot() {
    deletions.forEach(commitWork)
    commitWork(wipRoot.child)
    currentRoot = wipRoot
    wipRoot = null
  }

  function commitWork(fiber) {
    if (!fiber) {
      return
    }

    const domParent = fiber.parent.dom
    if (fiber.effectTag === "PLACEMENT" && fiber.dom != null) {
      domParent.appendChild(fiber.dom)
    } else if (fiber.effectTag === "UPDATE" && fiber.dom != null) {
      updateDom(fiber.dom, fiber.alternate.props, fiber.props)
    } else if (fiber.effectTag === "DELETION") {
      domParent.removeChild(fiber.dom)
    }

    commitWork(fiber.child)
    commitWork(fiber.sibling)
  }

  function render(element, container) {
    wipRoot = {
      dom: container,
      props: {
        children: [element],
      },
      alternate: currentRoot,
    }
    deletions = []
    nextUnitOfWork = wipRoot
  }

  let nextUnitOfWork = null
  let currentRoot = null
  let wipRoot = null
  let deletions = null

  function workLoop(deadline) {
    let shouldYield = false
    while (nextUnitOfWork && !shouldYield) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
      shouldYield = deadline.timeRemaining() < 1
    }

    if (!nextUnitOfWork && wipRoot) {
      commitRoot()
    }

    requestIdleCallback(workLoop)
  }

  requestIdleCallback(workLoop)

  function performUnitOfWork(fiber) {
    if (!fiber.dom) {
      fiber.dom = createDom(fiber)
    }

    const elements = fiber.props.children
    reconcileChildren(fiber, elements)

    if (fiber.child) {
      return fiber.child
    }
    let nextFiber = fiber
    while (nextFiber) {
      if (nextFiber.sibling) {
        return nextFiber.sibling
      }
      nextFiber = nextFiber.parent
    }
  }

  function reconcileChildren(wipFiber, elements) {
    let index = 0
    let oldFiber = wipFiber.alternate && wipFiber.alternate.child
    let prevSibling = null

    while (index < elements.length || oldFiber != null) {
      const element = elements[index]
      let newFiber = null

      const sameType = oldFiber && element && element.type == oldFiber.type

      if (sameType) {
        newFiber = {
          type: oldFiber.type,
          props: element.props,
          dom: oldFiber.dom,
          parent: wipFiber,
          alternate: oldFiber,
          effectTag: "UPDATE",
        }
      }
      if (element && !sameType) {
        newFiber = {
          type: element.type,
          props: element.props,
          dom: null,
          parent: wipFiber,
          alternate: null,
          effectTag: "PLACEMENT",
        }
      }
      if (oldFiber && !sameType) {
        oldFiber.effectTag = "DELETION"
        deletions.push(oldFiber)
      }

      if (oldFiber) {
        oldFiber = oldFiber.sibling
      }

      if (index === 0) {
        wipFiber.child = newFiber
      } else if (element) {
        prevSibling.sibling = newFiber
      }

      prevSibling = newFiber
      index++
    }
  }

  const Didact = {
    createElement,
    render,
  }

  /** @jsx Didact.createElement */
  const container = document.getElementById("root")

  const updateValue = e => {
    rerender(e.target.value)
  }

  const rerender = value => {
    const element = (
      <div>
        <input onInput={updateValue} value={value} />
        <h2>Hello {value}</h2>
      </div>
    )
    Didact.render(element, container)
  }

  rerender("World")
  ```

## ç¬¬ 7 èŠ‚ å‡½æ•°å¼ç»„ä»¶

æ¥ä¸‹æ¥æ·»åŠ å¯¹å‡½æ•°å¼ç»„ä»¶å†™æ³•çš„æ”¯æŒã€‚

æˆ‘ä»¬å°†æ•´ä¸ªæ ‡ç­¾æ”¹å†™æˆä¸€ä¸ªå‡½æ•°å¼ç»„ä»¶ï¼š

```jsx
function App(props) {
  return <h1>Hi {props.name}</h1>
}
const element = <App name="jojo" />
```

ä½¿ç”¨ç›®å‰çš„æˆ‘ä»¬ç¼–å†™çš„ createElement å‡½æ•°ï¼Œè½¬åŒ–ï¼Œåˆ™ä¼šæˆä¸ºå¦‚ä¸‹ï¼š

```jsx
function App(props) {
  return Didact.createElement("h1", null, "Hi ", props.name)
}
const element = Didact.createElement(App, {
  name: "foo",
})
```

å‡½æ•°å¼ç»„ä»¶ä¸»è¦æœ‰ä¸¤ç‚¹ä¸åŒã€‚

- å‡½æ•°å¼ç»„ä»¶çš„ fiber èŠ‚ç‚¹æ²¡æœ‰ dom å±æ€§
- ç»è¿‡è½¬åŒ–åï¼Œtype çš„å€¼ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œå…¶ children å±æ€§é€šè¿‡æ‰§è¡Œè¯¥å‡½æ•°è·å¾—ï¼Œè€Œéç›´æ¥ä» props ä¸­è·å–

åœ¨ performUnitOfWork å‡½æ•°çš„æœ€å¼€å§‹ï¼Œæˆ‘ä»¬å…ˆæ£€æŸ¥ fiber çš„ type æ˜¯å¦ä¸ºå‡½æ•°

```jsx
function performUnitOfWork(fiber) {
  // highlight-start
  const isFunctionComponent = fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  // highlight-end
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function updateFunctionComponent(fiber) {
  // TODO
}

function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}
```

åœ¨ updateHostComponent å‡½æ•°ä¸­ï¼Œå’Œä¹‹å‰çš„é€»è¾‘ä¸€æ ·ã€‚

åœ¨ updateFunctionComponent å‡½æ•°ä¸­ï¼Œæ›´æ–°å‡½æ•°å¼ç»„ä»¶çš„é€»è¾‘ã€‚æˆ‘ä»¬é€šè¿‡å°† fiber.props ä½œä¸ºå‚æ•°ï¼Œæ‰§è¡Œ fiber.type å‡½æ•°å¾—åˆ°çš„ childï¼Œæ”¾åˆ°æ•°ç»„ä¸­ï¼Œå†æ‰§è¡Œ reconcileChildren å‡½æ•°ã€‚

```jsx
function updateFunctionComponent(fiber) {
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}
```

æˆ‘ä»¬è¿˜éœ€è¦æ”¹åŠ¨ commitWork å‡½æ•°ä¸­çš„æŸä¸€å¤„ã€‚ç”±äºå‡½æ•°å€¼ç»„ä»¶æ²¡æœ‰ dom å±æ€§ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°å…¶çˆ¶èŠ‚ç‚¹çš„ dom å±æ€§ï¼Œè‹¥å…¶çˆ¶èŠ‚ç‚¹æ²¡æœ‰ dom å±æ€§ï¼Œåˆ™ä¸€ç›´å‘ä¸Šï¼Œç›´åˆ°æ‰¾åˆ°æœ‰ dom å±æ€§çš„ç¥–å…ˆä¸ºæ­¢ã€‚

```jsx
function commitWork(fiber) {
  if (!fiber) return

  // highlight-start
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
  // highlight-end

  if (fiber.effectTag === "PLACEMENT" && fiber.dom != null) {
    domParent.appendChild(fiber.dom)
  }
  // ...
  if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
}

function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
```

åœ¨ DELETION çš„æƒ…å†µï¼Œæˆ‘ä»¬é€’å½’åœ°å‘ä¸‹å¯»æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æœ‰ä¸€ä¸ª dom å±æ€§çš„å­èŠ‚ç‚¹ã€‚

## ç¬¬ 8 èŠ‚ Hooks

æœ€åä¸€æ­¥ï¼Œå®ç° 16.8 ä¸­çš„æ–°ç‰¹æ€§ä¹‹ä¸€ï¼ŒuseStateã€‚

å°† element æ”¹ä¸ºä¸€ä¸ªç»å…¸çš„è®¡æ•°å™¨ demoã€‚

```jsx
let wipFiber = null
let hookIndex = null

function updateFunctionComponent(fiber) {
  wipFiber = fiber
  hookIndex = 0
  wipFiber.hooks = []
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}

function useState(initial) {
  // TODO
}

/** @jsx Didact.createElement */
function Counter() {
  const [state, setState] = Didact.useState(1)
  return <h1 onClick={() => setState(c => c + 1)}>Count: {state}</h1>
}
const element = <Counter />
```

æˆ‘ä»¬é¦–å…ˆéœ€è¦åˆå§‹åŒ–ä¸€äº›å…¨å±€å˜é‡ï¼Œæ–¹ä¾¿å† useState ä¸­ä½¿ç”¨ã€‚

wipFiber è®°å½•å½“å‰æ­£åœ¨å¤„ç†çš„ fiberï¼Œå¹¶åœ¨æ›´æ–°å‡½æ•°å¼ç»„ä»¶çš„ fiber æ—¶ï¼Œåœ¨ fiber ä¸­æ·»åŠ  hooks å±æ€§ï¼Œæ”¯æŒå¤šæ¬¡è°ƒç”¨ useStateã€‚å¹¶ç”¨ hookIndex è®°å½•å½“å‰ hook çš„ä¸‹æ ‡ã€‚

```jsx
function useState(initial) {
  const oldHook =
    wipFiber.alternate &&
    wipFiber.alternate.hooks &&
    wipFiber.alternate.hooks[hookIndex]
  const hook = {
    state: oldHook ? oldHook.state : initial,
  }

  wipFiber.hooks.push(hook)
  hookIndex++
  return [hook.state]
}
```

å‡½æ•°å¼ç»„ä»¶è°ƒç”¨ hook æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ—§ hookï¼Œä» alternate ä¸­æ£€æŸ¥ã€‚

å¦‚æœæœ‰æ—§ hookï¼Œåˆ™ä»æ—§ hook çš„ state å€¼èµ‹å€¼ç»™æ–° hook çš„å€¼ï¼Œå¦åˆ™èµ‹å€¼ä¸ºåˆå§‹å€¼ initialã€‚

ä¹‹åï¼Œå°†æ–° hook æ·»åŠ åˆ° fiber ä¸­ï¼Œhook ä¸‹æ ‡è‡ªå¢ 1ï¼Œä»¥æ•°ç»„çš„æ–¹å¼è¿”å›è¯¥ stateã€‚

useState çš„è¿”å›å€¼çš„æ•°ç»„åº”è¯¥æœ‰ä¸¤ä¸ªä¹‹ï¼Œè¿˜åº”è¯¥è¿”å›ä¸€ä¸ªç”¨äºæ›´æ–° state çš„å‡½æ•°ã€‚

```jsx
function useState(initial) {
  const oldHook =
    wipFiber.alternate &&
    wipFiber.alternate.hooks &&
    wipFiber.alternate.hooks[hookIndex]
  const hook = {
    state: oldHook ? oldHook.state : initial,
    queue: [],
  }

  const actions = oldHook ? oldHook.queue : []
  actions.forEach(action => {
    hook.state = action(hook.state)
  })

  const setState = action => {
    hook.queue.push(action)
    wipRoot = {
      dom: currentRoot.dom,
      props: currentRoot.props,
      alternate: currentRoot,
    }
    nextUnitOfWork = wipRoot
    deletions = []
  }

  wipFiber.hooks.push(hook)
  hookIndex++
  return [hook.state, setState]
}
```

æˆ‘ä»¬å†æ¥å®šä¹‰ä¸€ä¸ª setState å‡½æ•°ã€‚æ¥æ”¶ä¸€ä¸ª actionï¼Œä¸ºä¸€ä¸ªå‡½æ•°ã€‚å°†è¯¥ action æ·»åŠ åˆ° hook çš„ queue å±æ€§ä¸­ã€‚

ä¹‹åçš„åšæ³•ä¸ render å‡½æ•°ç±»ä¼¼ï¼Œèµ‹æ–°å€¼ç»™å½“å‰æ­£åœ¨å¤„ç†çš„ root(wipRoot)ï¼ŒworkLoop å‡½æ•°æ—§å¯ä»¥å¼€å§‹æ–°çš„æ¸²æŸ“äº†ã€‚

åœ¨è¿™ä¹‹å‰ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ‰§è¡Œä¸€ä¸‹ action å‡½æ•°ã€‚å°†æ‰§è¡Œæ”¾åœ¨ä¸‹æ¬¡æ›´æ–°æ—¶ã€‚æŸ¥çœ‹æ˜¯å¦æœ‰ alternateï¼Œæœ‰åˆ™ä»ä¸­è·å–å¯¹åº”ä¸‹æ ‡çš„ hookï¼Œå¹¶éå† queue ä¸­çš„æ‰€æœ‰ action å‡½æ•°ï¼Œå°†æ‰§è¡Œ action å‡½æ•°çš„è¿”å›å€¼ä½œä¸ºä¸‹æ–°çš„ state çš„å€¼è¿”å›ã€‚

- æ‰€æœ‰ä»£ç 

  ```jsx
  function createElement(type, props, ...children) {
    return {
      type,
      props: {
        ...props,
        children: children.map(child =>
          typeof child === "object" ? child : createTextElement(child)
        ),
      },
    }
  }

  function createTextElement(text) {
    return {
      type: "TEXT_ELEMENT",
      props: {
        nodeValue: text,
        children: [],
      },
    }
  }

  function createDom(fiber) {
    const dom =
      fiber.type == "TEXT_ELEMENT"
        ? document.createTextNode("")
        : document.createElement(fiber.type)

    updateDom(dom, {}, fiber.props)

    return dom
  }

  const isEvent = key => key.startsWith("on")
  const isProperty = key => key !== "children" && !isEvent(key)
  const isNew = (prev, next) => key => prev[key] !== next[key]
  const isGone = (prev, next) => key => !(key in next)
  function updateDom(dom, prevProps, nextProps) {
    //Remove old or changed event listeners
    Object.keys(prevProps)
      .filter(isEvent)
      .filter(key => !(key in nextProps) || isNew(prevProps, nextProps)(key))
      .forEach(name => {
        const eventType = name.toLowerCase().substring(2)
        dom.removeEventListener(eventType, prevProps[name])
      })

    // Remove old properties
    Object.keys(prevProps)
      .filter(isProperty)
      .filter(isGone(prevProps, nextProps))
      .forEach(name => {
        dom[name] = ""
      })

    // Set new or changed properties
    Object.keys(nextProps)
      .filter(isProperty)
      .filter(isNew(prevProps, nextProps))
      .forEach(name => {
        dom[name] = nextProps[name]
      })

    // Add event listeners
    Object.keys(nextProps)
      .filter(isEvent)
      .filter(isNew(prevProps, nextProps))
      .forEach(name => {
        const eventType = name.toLowerCase().substring(2)
        dom.addEventListener(eventType, nextProps[name])
      })
  }

  function commitRoot() {
    deletions.forEach(commitWork)
    commitWork(wipRoot.child)
    currentRoot = wipRoot
    wipRoot = null
  }

  function commitWork(fiber) {
    if (!fiber) {
      return
    }

    let domParentFiber = fiber.parent
    while (!domParentFiber.dom) {
      domParentFiber = domParentFiber.parent
    }
    const domParent = domParentFiber.dom

    if (fiber.effectTag === "PLACEMENT" && fiber.dom != null) {
      domParent.appendChild(fiber.dom)
    } else if (fiber.effectTag === "UPDATE" && fiber.dom != null) {
      updateDom(fiber.dom, fiber.alternate.props, fiber.props)
    } else if (fiber.effectTag === "DELETION") {
      commitDeletion(fiber, domParent)
    }

    commitWork(fiber.child)
    commitWork(fiber.sibling)
  }

  function commitDeletion(fiber, domParent) {
    if (fiber.dom) {
      domParent.removeChild(fiber.dom)
    } else {
      commitDeletion(fiber.child, domParent)
    }
  }

  function render(element, container) {
    wipRoot = {
      dom: container,
      props: {
        children: [element],
      },
      alternate: currentRoot,
    }
    deletions = []
    nextUnitOfWork = wipRoot
  }

  let nextUnitOfWork = null
  let currentRoot = null
  let wipRoot = null
  let deletions = null

  function workLoop(deadline) {
    let shouldYield = false
    while (nextUnitOfWork && !shouldYield) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
      shouldYield = deadline.timeRemaining() < 1
    }

    if (!nextUnitOfWork && wipRoot) {
      commitRoot()
    }

    requestIdleCallback(workLoop)
  }

  requestIdleCallback(workLoop)

  function performUnitOfWork(fiber) {
    const isFunctionComponent = fiber.type instanceof Function
    if (isFunctionComponent) {
      updateFunctionComponent(fiber)
    } else {
      updateHostComponent(fiber)
    }
    if (fiber.child) {
      return fiber.child
    }
    let nextFiber = fiber
    while (nextFiber) {
      if (nextFiber.sibling) {
        return nextFiber.sibling
      }
      nextFiber = nextFiber.parent
    }
  }

  let wipFiber = null
  let hookIndex = null

  function updateFunctionComponent(fiber) {
    wipFiber = fiber
    hookIndex = 0
    wipFiber.hooks = []
    const children = [fiber.type(fiber.props)]
    reconcileChildren(fiber, children)
  }

  function useState(initial) {
    const oldHook =
      wipFiber.alternate &&
      wipFiber.alternate.hooks &&
      wipFiber.alternate.hooks[hookIndex]
    const hook = {
      state: oldHook ? oldHook.state : initial,
      queue: [],
    }

    const actions = oldHook ? oldHook.queue : []
    actions.forEach(action => {
      hook.state = action(hook.state)
    })

    const setState = action => {
      hook.queue.push(action)
      wipRoot = {
        dom: currentRoot.dom,
        props: currentRoot.props,
        alternate: currentRoot,
      }
      nextUnitOfWork = wipRoot
      deletions = []
    }

    wipFiber.hooks.push(hook)
    hookIndex++
    return [hook.state, setState]
  }

  function updateHostComponent(fiber) {
    if (!fiber.dom) {
      fiber.dom = createDom(fiber)
    }
    reconcileChildren(fiber, fiber.props.children)
  }

  function reconcileChildren(wipFiber, elements) {
    let index = 0
    let oldFiber = wipFiber.alternate && wipFiber.alternate.child
    let prevSibling = null

    while (index < elements.length || oldFiber != null) {
      const element = elements[index]
      let newFiber = null

      const sameType = oldFiber && element && element.type == oldFiber.type

      if (sameType) {
        newFiber = {
          type: oldFiber.type,
          props: element.props,
          dom: oldFiber.dom,
          parent: wipFiber,
          alternate: oldFiber,
          effectTag: "UPDATE",
        }
      }
      if (element && !sameType) {
        newFiber = {
          type: element.type,
          props: element.props,
          dom: null,
          parent: wipFiber,
          alternate: null,
          effectTag: "PLACEMENT",
        }
      }
      if (oldFiber && !sameType) {
        oldFiber.effectTag = "DELETION"
        deletions.push(oldFiber)
      }

      if (oldFiber) {
        oldFiber = oldFiber.sibling
      }

      if (index === 0) {
        wipFiber.child = newFiber
      } else if (element) {
        prevSibling.sibling = newFiber
      }

      prevSibling = newFiber
      index++
    }
  }

  const Didact = {
    createElement,
    render,
    useState,
  }

  /** @jsx Didact.createElement */
  function Counter() {
    const [state, setState] = Didact.useState(1)
    return <h1 onClick={() => setState(c => c + 1)}>Count: {state}</h1>
  }
  const element = <Counter />
  const container = document.getElementById("root")
  Didact.render(element, container)
  ```

## æ€»ç»“

æœ¬æ–‡é™¤äº†å¸®åŠ©ä½ æ›´æ¸…æ™°çš„ç†è§£ React æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæœ¬æ–‡çš„å¦ä¸€ä¸ªç›®çš„æ˜¯èƒ½è®©ä½ æ›´å®¹æ˜“åœ°æ·±å…¥ React ä»£ç é€»è¾‘ã€‚è¿™ä¹Ÿæ˜¯æˆ‘ä»¬é€‰æ‹©ä½¿ç”¨äº†åŒæ ·çš„å‡½æ•°å‘½åã€‚

ä¾‹å¦‚ï¼Œåœ¨ä½¿ç”¨äº†åŸç‰ˆ React åº“çš„æŸå¤„ä»£ç æ·»åŠ æ–­ç‚¹ï¼Œå‡½æ•°è°ƒç”¨å †æ ˆä¼šæ˜¾ç¤º

- workLoop
- performUnitOfWork
- updateFunctionComponent

æœ¬æ–‡æ²¡æœ‰åŒ…å«å…¶ä»–çš„ React ç‰¹æ€§å’Œæ€§èƒ½ä¼˜åŒ–ã€‚æ¯”å¦‚ï¼Œä¸‹é¢æ˜¯ React äºæœ¬æ–‡åšæ³•ä¸åŒçš„ï¼š

- åœ¨ Didact ä¸­ï¼Œrender é˜¶æ®µéå†æ•´ä¸ªæ ‘ã€‚è€Œ React åˆ™æ˜¯æ ¹æ®ä¸€äº›å†…éƒ¨æç¤ºï¼Œé€‰æ‹©æ€§çš„è·³è¿‡æŸäº›èŠ‚ç‚¹ï¼Œåªéå†éƒ¨åˆ†èŠ‚ç‚¹ã€‚
- åœ¨ commit é˜¶æ®µæˆ‘ä»¬ä¹Ÿéå†äº†æ•´ä¸ªæ ‘ã€‚React å†…éƒ¨å­˜å‚¨äº†ä¸€ä¸ªåˆ—è¡¨ï¼Œåªè®°ä½äº†ä½¿ç”¨äº† effects çš„ fiberï¼Œå¹¶ä¸”æ›´æ–°æ—¶åªè®¿é—®è¿™äº› fiber èŠ‚ç‚¹ã€‚
- Every time we build a new work in progress tree, we create new objects for each fiber. React recycles the fibers from the previous trees.
- å½“ Didact åœ¨ render é˜¶æ®µæ¥æ”¶åˆ°æ›´æ–°ï¼Œå®ƒæ”¾å¼ƒå½“å‰çš„å·¥ä½œï¼Œå¹¶é‡æ–°ä»å¤´å¼€å§‹éå†æ ‘ã€‚React åˆ™æ˜¯å°†æ›´æ–°åŠ ä¸Šè¿‡æœŸæ—¶é—´æˆ³ï¼Œæ¥åˆ¤æ–­é‚£ä¸ªæ›´æ–°æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ã€‚
- è¿˜æœ‰å„ç§å…¶ä»–çš„â€¦

è¿˜æœ‰ä¸€äº›ç‰¹æ€§æ˜¯ä½ å¯ä»¥å°è¯•æ·»åŠ è¿›å»çš„ï¼š

- å°† style æ”¹ä¸ºå¯ä»¥ä½¿ç”¨ object
- æ‰å¹³åŒ– children æ•°ç»„
- å®ç° useEffect hook
- reconciliation é˜¶æ®µä½¿ç”¨ key

## å‚è€ƒ

- [https://pomb.us/build-your-own-react/](https://pomb.us/build-your-own-react/)
- [https://andela.com/insights/building-your-own-version-of-react-from-scratch-part-1/](https://andela.com/insights/building-your-own-version-of-react-from-scratch-part-1/)
